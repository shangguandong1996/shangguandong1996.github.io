<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MACS2的原理介绍]]></title>
    <url>%2F2019%2F08%2F30%2FMACS2%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[泊松分布 泊松分布是统计与概率中重要的离散分布之一，泊松分布表示在一定的时间或空间内出现的事件个数，比如某一服务设施在一定时间内受到的服务请求的次数、DNA序列的变异数、汽车站台的等候人数。根据MACS的论文中所描述的，Chip-Seq实验中全基因组的reads分布恰好是符合泊松分布的。 泊松分布的概率分布为 \[ P(X = k)=\frac{e^{-\lambda}\lambda^{k}}{k!} \] 其中e代表的是自然常数，而\(\lambda\)是单位时间（或单位面积）内随机事件的平均发生率，比如在一定时间内某一服务设施受到的请求次数是5次。 另外，泊松分布实际上只有一个参数，即\(\lambda\)，其方差和期望也是\(\lambda\)。同时，随着\(\lambda\)的增加，图像分布会趋于对称。 参考资料 二项分布、泊松分布、正态分布的关系 泊松分布和指数分布：10分钟教程 wiki_泊松分布 MACS的算法概览 Adjusting read position based on fragment size distribution Chip-Seq的主要过程为：交联——超声破碎——特异性识别——测序。所以我们测序得到的片段就是我们转录因子结合位点周围的片段。需要注意的一点是，MACS软件出现的年代是2008年，那时候的测序读长都很短，大约50bp左右，且以单端测序为主，并没有真实反应DNA-蛋白结合片段的长度。所以说，我们如果拿测得的50bp去做reads数目的堆积，势必会与真实的结合位置有一定的偏移。事实上，测序的短reads会在真实的结合位置两侧形成双峰，如下图所A示。这也是MACS双峰模型构建的理论基础。 值得一提的是，像转录因子一类的蛋白与DNA，其结合位点比较narrow，所以双峰模型的构建是比较合理的。但像图B所示的，一些蛋白与DNA会产生较宽的结合区域（诸如一些组蛋白修饰），这时候双峰就不那么显著了。 更为麻烦的是，有时候会有一些混合的结合位点模式，比如Polll蛋白，其会在启动子区域结合，也会覆盖整个基因区域。 为了衡量真实的测序片段大小，d，MACS会粗略地以2倍的超声破碎片段长度作为window来鉴定初步的富集区域。为了避免重复区域或者PCR导致极端富集区域的影响，MACS会随机挑选1000个区域作为模型peak构建区域。这些区域的reads富集程度是基因组背景的10-30倍。对于每个区域的模型peak，MACS都会分离出对比到正链和负链上的reads，然后分别计算出这些reads的位置。从而分别构建出这个区域内的正负链上的模型peak，正负链上模型peak顶点之间距离就记为d。在d确定之后，所有的reads都会朝着3'的方向横移（shift）d/2的距离，从而更好地模拟出蛋白-DNA结合位点。 在2012年的Identifying ChIP-seq enrichment using MACS这篇文章中，作者也提到对于一些过度破碎或者有着很宽的结合位点情况，可能会造成算出来的d很小。对于这种情况，我们一般建议用一个特定的片段长度，而非是预测出来的d。 注意shift和extend的区别，在2008年原始的MACS文章中，作者用的是shift，而到了12年的文章，作者写错，写成了extend。当然，在MACS2中，这两种情况都存在了。 Calculate peak enrichment using local background normalization 基于先前已经调整位置的reads，MACS会在全基因组范围内以2d长度的window来寻找那些有显著富集的区域。有重叠的window会融合成一个候选区域。因为会有许多因素影响不同范围内的reads富集程度，所以MACS用了动态的\(\lambda_{local}\)参数来对于reads数目的富集进行泊松分布的建模。即MACS并不会用一个常数\(\lambda\)，而是用一个会在不同区域有变化的\(\lambda_{local}\)。动态参数值定义为 \[ \lambda_{local}=max(\lambda_{BG},[\lambda_{region},\lambda_{1k}],\lambda_{5k},\lambda_{10k}) \] \(\lambda_{BG}\)来自于全基因组的计算，\(\lambda_{region}\)则来自在control中的对应区域，剩下的\(\lambda_x\)则来自control中，以得到的候选区域为中心，1k，5k，10k范围内的区域计算。见下图 lambda 如果control不在，则local值只是在Chip的样本中计算，而region和1k值也会被舍弃。同时如果Chip-Seq和control的样本测序深度不同，MACS会默认地把测序深度更深的样本缩放。 关于\(\lambda\)以及p值这一步的计算可能需要看源代码才可以了解了。 但根据MACS2的wiki来说，似乎p值和\(\lambda\)的计算都是以单个碱基为单位考虑的。 基于泊松分布的模型，我们就可以以单尾检验，计算出p值了。MACS默认以p=1 x 10-5为阈值。 Estimating the empirical false discovery rate by exchanging ChIP-seq and control samples 这里MACS用的Chip和control的置换，从而检验出FDR值我并没有看懂。不过MACS2用的已经是Benjamini-Hochberg方法了，还是比较好懂的。 参考资料： Evaluation of Algorithm Performance in ChIP-Seq Peak Detection Model-based Analysis of ChIP-Seq (MACS) Identifying ChIP-seq enrichment using MACS In-depth-NGS-Data-Analysis-Course MACS2中的一些参数介绍 -f/--format FORMAT 可以接受多种格式参数，默认使用AUTO来检测格式。但并不能检测“BAMPE”或者“BEDPE”格式，即双端测序格式。所以，当你的数据是双端测序数据时，你应该用BAMPE或者BEDPE参数。当你设置成双端参数的时候，MACS2就会跳过建模计算d的那一步，而是直接用片段的insert size来建立堆积。 --extsize 如果使用这个参数，那么MACS就会使用你设置的数值，来把reads从5‘—3’补齐到你指定的数值。这个参数只有当--nomodel参数设置了，或者MACS建模失败，--fix-bimodal开启的时候才可以用。 --shift shift参数会先于extsize参数执行。如果你设置的数值为正，reads会从5‘—3’偏移，而数值为负，reads会从3'—5‘偏移。当格式为BAMPE或者BEDPE的时候，不能设置参数。 --broad 会放宽cutoff的阈值，然后把临近的区域结合起来，形成较宽的peak区域。与broad-cutoff参数是一起的，broad-cutoff参数默认为q-value的参数，为0.1。 有趣的是，shift后面数值如果为正，则正负链的reads会朝着中心偏移，如果后面数值为负，则正负链的reads会各自远离中心，即正链reads向左，负链reads向右。 给个例子： 1234567891011Original Reads:chr1 500 550 read1 . (+)chr1 700 750 read2 . (-)--shift -100chr1 400 450 read1 . (+)chr1 800 850 read2 . (-)--extsize 200chr1 400 600 read1 . (+)chr1 650 850 read2 . (-) 参考资料： MACS_github google_group 如何使用MACS进行peak calling]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mfuzz的使用]]></title>
    <url>%2F2019%2F08%2F30%2FMfuzz%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[最近在进行ATAC和RNA-Seq的联合分析，由于处理的材料是时间相关的，所以time-course也是一个可以分析的点。在一位刘潜老哥的帮助下，我找到了一篇靠谱熊 转录组时间序列数据处理 的文章，里面提到了mfuzz这个包。里面的软聚类的思想非常符合我的预期，然后就决定拿这个包进行我time-course的分析。为了更好的分析，我决定先翻译下这个包，了解下这个包的大致思想。 1 Overview 这部分是我偷懒的随便写的。。。。。。 感觉time-course的方法一般就是聚类。常见的聚类分为三种，分别是层次聚类（Hierarchical Clustering）、硬聚类（hard clustering）、软聚类（soft clustering）。层次聚类好像一般就是像热图那种。看了pheatmap的文档，感觉pheatmap就是层次聚类，当然你可以设置k_means，变成硬聚类。硬聚类常见的就是k-menas。软聚类就是我们这会要用到的这个包的核心思路。 2 Installation requirements 见Bioconductor的安装方法。 3 Data pre-processing 数据集是来源于酵母细胞循环表达数据。6178个基因，横跨160分钟的17个时间点。用的是芯片数据。 12345678&gt; head(yeast@assayData$exprs) cdc28_0 cdc28_10 cdc28_20 cdc28_30 cdc28_40 cdc28_50 cdc28_60 cdc28_70 cdc28_80 cdc28_90 cdc28_100 cdc28_110 cdc28_120 cdc28_130 cdc28_140 cdc28_150 cdc28_160YDR132C 0.19 0.30 -0.29 0.29 -0.31 0.23 0.20 -0.08 0.19 -0.51 0.00 -0.31 0.11 -0.02 0.20 0.36 -0.54YMR012W -0.15 -0.15 -0.04 -0.28 -0.39 0.03 0.22 0.04 -0.15 0.37 0.47 -0.10 -0.09 NA -0.04 0.07 0.19YLR214W 0.38 0.30 -0.68 -0.52 -0.43 -0.13 -0.17 0.26 -0.03 -0.34 -0.01 -0.20 0.10 NA 0.45 0.40 0.63YLR116W 0.17 0.06 -0.21 0.19 0.33 0.44 0.46 0.38 -0.15 -0.03 0.04 -0.42 -0.15 0.02 NA -0.51 -0.61YDR203W 0.85 -0.10 -0.56 -0.31 -0.43 0.00 -0.34 0.17 0.40 -0.37 0.15 0.24 0.24 0.17 -0.12 -0.02 0.02YEL059C-A 0.45 0.20 0.06 0.10 -0.21 -0.08 -0.27 -0.01 -0.29 0.41 -0.08 -0.22 -0.27 NA -0.30 0.25 0.26 3.1 Missing value 第一步，去除那些有超过25%数据缺失的基因。注意这些数据缺失值应该是设为NA。 12yeast.r &lt;- filter.NA(yeast, thres=0.25)49 genes excluded. 这里就如上面的数据一样，一行即一个基因有16个时间点的数据，如果16个时间点里面有25%，即4个时间点都是NA，则剔除这个基因。 123456&gt; nrow(yeast)Features 3000 &gt; nrow(yeast.r)Features 2951 Fuzzy c-means就像其他聚类算法一样，其并不允许有缺失值的存在。所以我们会对剩下那些缺失值（16个数据点里面就缺了1个2个那种）进行填充。用的是对应基因的平均表达值。 对于RNA-Seq来说，你可以加上一些pseudocount，比如0.01。 1yeast.f &lt;- fill.NA(yeast.r,mode="mean") 当然，你也可以用（weighted） k-nearest neighbour method。（mode='knn'/'wknn'）。这些方法相比较而言比上面这种简单的方法要好，但需要耗费更多的算力。 3.2 Filtering 许多已经出版的聚类分析包含过滤的步骤，从而来去除那些表达相对比较低的，或者表达不怎么变化的。通常来说，比较受欢迎的就是样本的标准差作为阈值。 1tmp &lt;- filter.std(yeast.f,min.std=0) 然而在基因低表达到高表达的过程中，变化是非常平缓的。所以给定阈值筛选并不一定是可靠的，可能是非常武断。因为现在并没有很多有说服力的筛选手段，所以我们还是避免对基因数据做提前的筛选。这可以避免损失一些有生物学重大意义的基因。 比如1,2,4,10,12,13,15。看起来变化很大，但方差可能并不如你想象中的那么大。 Standardisation 由于聚类是在欧几里德空间中进行的，因此基因的表达值被标准化为平均值为零，标准差为1。该步骤确保了在欧几里得空间中具有相似表达模式的基因是相互接近的。 1yeast.s &lt;- standardise(yeast.f) 重要的是，Mfuzz认为输入的表达数据是完全经过前期数据标准化的。standardise 并不能代替标准化步骤。注意差异：标准化是为了让不同的样品间可以比较，而Mufzz中standardisation则是让转录本或者基因间可以比较。 4 Soft clustering of gene expression data 聚类可以用来解释基因表达的调控机制。众所周知的，基因的表达并不是开和关的，而是一个逐渐变化的过程。一个聚类算法应该展现出一个基因有多么的符合dominant cluster pattern。软聚类应该是一个非常好的方法，因为其可以利用membership \(μ_{ij}\)衡量一个基因 i跟cluster j的关系。 其实就是说基因A跟每个cluster都有关系，无非是membership score的值不一样而已。 软聚类的mfuzz函数基于的是e1071包的fuzzy c-means算法。对于软过滤而言，聚类中心点\(c_j\)来源于所有聚类成员的权重值。在图中的membership值可以用mfuzz.plot来展现。你也可以用mfuzz.plot2来看，其会有更多的选项。 值得注意的是，clustering只会基于表达矩阵，不会使用phenoData的任何信息。还有，在mfuzz中重复会被当作是独立的信息，所以他们应该提前被算好平均值，或者放进不同的ExpressionSet对象里面。 12&gt; cl &lt;- mfuzz(yeast.s,c=16,m=1.25)&gt; mfuzz.plot(yeast.s,cl=cl,mfrow=c(4,4),time.labels=seq(0,160,10)) 123456789101112131415161718192021222324# center代表的应该是你选择的16个中心点的表达模式## 感觉可以用来画图&gt; head(cl$centers,2) cdc28_0 cdc28_10 cdc28_20 cdc28_30 cdc28_40 cdc28_50 cdc28_60 cdc28_70 cdc28_80 cdc28_90 cdc28_100 cdc28_110 cdc28_120 cdc28_130 cdc28_140 cdc28_150 cdc28_1601 0.1971169 -1.0925729 -1.6203551 -0.7961482 -0.33954720 -0.1567524 -0.05036767 0.08380756 0.5122518 0.3843354 0.4905732 0.437668149 0.4526805 0.3170533 0.2866267 0.2890568 0.60457312 -0.7393245 -0.5872038 0.2438611 -0.1883262 0.03321276 -1.0122666 -0.38203192 -0.47328266 -0.6289479 2.1494891 0.5371715 -0.001270464 -0.5672875 0.2288121 0.2331435 0.5896372 0.5646142# size代表的是各个聚类的基因数目 &gt; head(cl$size,2)[1] 175 244# cluster代表的是基因所属的membership score最高的那个簇&gt; head(cl$cluster,5)YDR132C YMR012W YLR214W YLR116W YDR203W 4 11 16 13 16 # membership代表的是每个基因对应16个簇的membership值&gt; head(cl$membership,5) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16YDR132C 0.014386854 0.0023657075 0.0478663840 0.47749014 0.007117060 0.070156647 0.010004348 0.051767933 0.01711759 0.028929516 0.0064926466 0.011933880 0.110039692 0.025007449 0.033967103 0.08535705YMR012W 0.082025023 0.1807366237 0.0088059459 0.00371571 0.012467968 0.002590922 0.127711735 0.007948114 0.06412901 0.004626184 0.3408675360 0.105343965 0.008278282 0.011112051 0.012020122 0.02762081YLR214W 0.130082565 0.0047176611 0.0041702207 0.06382311 0.001340277 0.004636745 0.013298969 0.043267912 0.21204674 0.016651050 0.0850329333 0.023956515 0.010243391 0.003459240 0.022271137 0.36100153YLR116W 0.002047923 0.0008467741 0.0412749579 0.01409627 0.002758020 0.034171711 0.001234725 0.002968499 0.00083482 0.003580831 0.0006540104 0.003016454 0.846273635 0.023517377 0.012508494 0.01021550YDR203W 0.083941355 0.0008482787 0.0008575124 0.02562416 0.001318053 0.004043468 0.001274160 0.032185727 0.12237271 0.002649867 0.0125075149 0.003545481 0.005389429 0.001504605 0.007198611 0.69473907 123mfuzz.plot(eset,cl,mfrow=c(1,1),colo,min.mem=0,time.labels,new.window=TRUE)colo可以设置颜色，min.mem可以设置membership的阈值 4.1 Setting of parameters for FCM clustering 对于fuzzy c-means来说，模糊值m和聚类数c必须提前设置好。对于m，我们应该选择一个可以防止随机数据聚类的值。值得注意的是，fuzzy 聚类可以遵守这样的准则，随机数据并不能被聚类。这相比于硬聚类（例如k-means）来说，是一个明显的优点。因为其即使在随机数据中，也可以检测到cluster。为了达到这一点，你可以使用下列选项： partcoef函数，来检测是否在某一特定的m设置下，随机数也会被聚类 或者直接计算 12&gt; m1 &lt;- mestimate(yeast.s)&gt; m1 # 1.15 设置一个合理的聚类值c是很有挑战性的，尤其是那些short time series，很有可能就会有overlapping clusters。我们可以设置一个最大的c值，大到最后出现了一个空的empty clusters（看 cselection函数） 12345678# 不太懂repeat值代表了什么&gt; cselection(yeast.s,m=1.25,crange=seq(4,32,4),repeats=5,visu=TRUE) c:4 c:8 c:12 c:16 c:20 c:24 c:28 c:32repeats:1 4 8 12 16 19 24 27 31repeats:2 4 8 12 16 20 23 28 30repeats:3 4 8 12 16 20 23 28 32repeats:4 4 8 12 16 20 24 28 31repeats:5 4 8 12 16 20 23 27 32 在cluster centroid之间最小距离\(D_{min}\) 也可以作为簇有效指数。在这里，我们可以检测不同的c值之间的\(D_{min}\)。我们可以预期D.min在达到最合适值之后，下降幅度会变低。你也可以选择 4.2 Cluster score Membership值也可以暗示两个向量之间的相关性。如果两个基因对于一个特定的cluster都有高的membership score，那么他们通常来说表达模式是相似的。我们对于高于阈值α的基因，叫做这个cluster的α-core。 membersip score的设置通常可以作为基因的后验筛选。我们可以用acore函数。 12tmp &lt;- acore(yeast.s,cl,min.acore = 0.5)# 生成的似乎是个列表，里面有16个。就可以知道每个簇里面含有的基因ID了。 5 Cluster stability FCM参数的变化也可以体现出cluster的稳健性。我们认为那些稳健的clusters具有某个特征，即在m的变化下，也只会展现出很小的变化。 12cl2 &lt;- mfuzz(yeast.s,c=16,m=1.35)mfuzz.plot(yeast.s,cl=cl2,mfrow=c(4,4),time.labels=seq(0,160,10)) 6 Global clustering structures 软聚类有趣的一点就是clusters之间的overlap或者coupling。在cluster k和l之间的coupling coefficient \(V_{kl}\) 可以定义为： \[ V_{kl}=\frac{1}{N}\sum^{N}_{i=1}{\mu_{ik}}{\mu_{il}} \] N是整个基因表达矩阵的数目。如果coupling值越低，说明两者的表达模式距离越远。如果越高，说明表达模式越相近。 12O &lt;- overlap(cl)Ptmp &lt;- overlap.plot(cl,over=O,thres=0.05) 7 Mfuzzgui - the graphical user interface for the Mfuzz pack-age mfuzz有图形化界面，不过我没去用。 小结 最近期末考试复习太忙了。。。。有空再加上点注意事项。]]></content>
      <categories>
        <category>软件的使用</category>
      </categories>
      <tags>
        <tag>Bioinformatics</tag>
      </tags>
  </entry>
</search>
